#lang racket
(require rsound rsound/envelope mrlib/gif racket/draw 2htdp/universe)
(define (sort-cmp less-than? k cache)
  (if cache
      (let ([known (make-hash)])
        (λ (x y) (when (not (hash-has-key? known x))
                   (hash-set! known x (k x)))
          (when (not (hash-has-key? known y))
                   (hash-set! known y (k y)))
          (less-than? (hash-ref known x) (hash-ref known y))))
      (λ (x y) (less-than? (k x) (k y)))))
(define (swap vec i j) (vector-set*! vec j (vector-ref vec i) i (vector-ref vec j)))
(define (selection-sort! vec cmp [start 0] [end (vector-length vec)])
  (for ([i (in-range start end)])
    (let ([jmin i])
      (for ([j (in-range (add1 i) end)])
        (when (cmp (vector-ref vec j) (vector-ref vec jmin))
          (set! jmin j)))
      (swap vec i jmin))))
(define (insertion-pass vec cmp [end (vector-length vec)] [start 0] [step -1])
  (for ([j (in-range end start step)]
        #:break (or (< (+ j step) start)
                    (cmp (vector-ref vec (+ j step)) (vector-ref vec j))))
    (swap vec j (+ j step))))
(define (insertion-sort! vec cmp [start 0] [end (vector-length vec)])
  (for ([i (in-range (add1 start) end)])
    (insertion-pass vec cmp i start)))
(define (shell-sort! vec cmp [start 0] [end (vector-length vec)] #:gaps [gaps '(1750 701 301 132 57 23 10 4 1)])
  (for ([g (in-list (dropf gaps (λ (g) (>= g (- end start)))))])
    (for ([i (in-range start (- end (modulo end g)))])
      (insertion-pass vec cmp i (+ start g -1) (* -1 g)))))
(define (bubble-pass vec cmp [start 0] [end (vector-length vec)] [step 1])
  (let ([is-swap #f] [break? (if (negative? (sgn step)) < >=)])
    (for ([i (in-range start end step)] #:break (break? (+ i step) end))
      (when (cmp (vector-ref vec (+ i step)) (vector-ref vec i))
        (swap vec (+ i step) i) (set! is-swap #t))) is-swap))
(define (bubble-sort! vec cmp [start 0] [end (vector-length vec)])
  (let loop ([is-swap (bubble-pass vec cmp start end)])
    (when is-swap (loop (bubble-pass vec cmp start end)))))
(define (hybrid-length len sort1 sort2)
  (λ (vec cmp [start 0] [end (vector-length vec)])
    ((if (<= (- end start) len) sort1 sort2) vec cmp start end)))
(define (hybrid-quick k sort #:partition [part lomuto-partition])
  (λ (vec cmp [start 0] [end (vector-length vec)])
    (define (quick start end d)
      (when (< start end)
        (if (> d 0)
            (let ([p (part vec cmp start end)])
              (quick start p (sub1 d))
              (quick (add1 p) end (sub1 d)))
            (sort vec cmp start end))))
    (quick start end k)))
(define (hybrid-merge len sort)
  (λ (vec cmp [start 0] [end (vector-length vec)])
    (define (merge i j end)
      (cond [(or (>= j end) (>= i j)) (void)]
            [(cmp (vector-ref vec j) (vector-ref vec i))
             (swap vec i j)
             (when (< (add1 i) j)
               (for ([k (in-range (add1 i) j)])
                 (swap vec k j)))
             (merge (add1 i) (add1 j) end)]
            [else (merge (add1 i) j end)]))
    (define (top-down start end)
      (cond [(<= (- end start) 1) (void)]
            [(<= (- end start) len) (sort vec cmp start end)]
            [(quotient (- end start) 2) =>
             (λ (t) (top-down start (+ start t)) (top-down (+ start t) end)
               (merge start (+ start t) end))]))
    (top-down start end)))
(define (merge-sort! vec cmp [start 0] [end (vector-length vec)])
  ((hybrid-merge 2 (λ (vec cmp [start 0] [end 2])
                    (unless (cmp (vector-ref vec start) (vector-ref vec (add1 start)))
                      (swap vec start (add1 start))))) vec cmp start end))
(define (intro-sort! vec cmp [start 0] [end (vector-length vec)]
                     #:scale [scale 3/2] #:threshold [thresh 7] #:partition [part lomuto-partition])
  ((hybrid-quick (exact-floor (* scale (log (- end start))))
                 (hybrid-length thresh insertion-sort! heap-sort!) #:partition part)
   vec cmp start end))


(define (cocktail-sort! vec cmp [start 0] [end (vector-length vec)])
  (let loop ([is-swap (bubble-pass vec cmp start end)])
    (when is-swap
      (set! is-swap (bubble-pass vec (λ (a b) (cmp b a)) (sub1 end) start -1))
      (when is-swap (loop (bubble-pass vec cmp start end))))))
(define (gnome-sort! vec cmp [start 0] [end (vector-length vec)])
  (let loop ([i start])
    (if (or (= i start) (cmp (vector-ref vec (sub1 i)) (vector-ref vec i)))
        (if (= (add1 i) end) (void) (loop (add1 i)))
        (and (swap vec i (sub1 i)) (loop (sub1 i))))))
(define (comb-sort! vec cmp [start 0] [end (vector-length vec)] #:shrink [shrink 1.3])
  (let loop ([gap (- end start)] [is-swap #t])
    (when (or (bubble-pass vec cmp start end gap) is-swap)
      (set! is-swap #t))
    (when is-swap
      (let ([x (max 1 (exact-floor (/ gap shrink)))])
        (loop x (> x 1))))))
(define (hoare-partition vec cmp [low 0] [high (vector-length vec)])
  (let loop ([i low] [j (sub1 high)] [pivot (vector-ref vec (quotient (+ low high -1) 2))])
    (let loop2 () (when (and (< i high) (cmp (vector-ref vec i) pivot)) (set! i (add1 i)) (loop2)))
    (let loop2 () (when (and (>= j low) (> j i) (cmp pivot (vector-ref vec j))) (set! j (sub1 j)) (loop2)))
    (if (>= i j) j (and (swap vec i j) (loop i j pivot)))))
(define (lomuto-partition vec cmp [low 0] [high (vector-length vec)])
  (let ([i low] [pivot (vector-ref vec (sub1 high))])
      (for ([j (in-range low (sub1 high))])
        (when (cmp (vector-ref vec j) pivot)
          (swap vec i j) (set! i (add1 i))))
      (swap vec i (sub1 high)) i))
(define (quick-sort! vec cmp [start 0] [end (vector-length vec)] #:partition [part lomuto-partition])
  (define (quicksort low high)
    (when (< low high)
      (let ([p (part vec cmp low high)])
        (quicksort low p) (quicksort (add1 p) high))))
  (quicksort start end))
(define (lomuto-sort! vec cmp [start 0] [end (vector-length vec)])
  (quick-sort! vec cmp start end))
(define (hoare-sort! vec cmp [start 0] [end (vector-length vec)])
  (quick-sort! vec cmp start end #:partition hoare-partition))
(define (heap-sort! vec cmp [start 0] [end (vector-length vec)])
  (define (parent i) (+ start -1 (exact-ceiling (/ (- i start) 2))))
  (define (child1 i) (+ 1 start (* 2 (- i start))))
  (define (sift-down k end)
    (let loop ([root k] [child (child1 k)])
      (cond [(or (< root k) (>= root end) (>= child end)) (void)]
            [(cmp (vector-ref vec root) (vector-ref vec child))
             (cond [(>= (add1 child) end)
                    (swap vec root child)]
                   [(cmp (vector-ref vec child) (vector-ref vec (add1 child)))
                    (swap vec root (add1 child))
                    (loop (add1 child) (child1 (add1 child)))]
                   [else (swap vec root child)
                    (loop child (child1 child))])]
            [(>= (add1 child) end) (void)]
            [(cmp (vector-ref vec root) (vector-ref vec (add1 child)))
             (swap vec root (add1 child))
             (loop (add1 child) (child1 (add1 child)))]
            [else (void)])))
  ;heapify
  (for ([x (in-range (add1 (parent (sub1 end))) (sub1 start) -1)])
    (sift-down x end))
  (for ([end (in-range end (add1 start) -1)])
    (swap vec start (sub1 end))
    (sift-down start (sub1 end))))
(define (bucket-sort! base len extract vec [start 0] [end (vector-length vec)])
  (let ([idx (make-vector base '#())])
    (for ([r (in-range len)])
      (for ([x (in-vector vec start end)] [i (in-naturals)])
        (let ([k (extract x r)])
          (vector-set! idx k (vector-append (vector-ref idx k) (vector (+ i start))))))
      (vector-copy! vec start (for/fold ([res '#()]) ([v (in-vector idx)])
                                (vector-append res (vector-map (λ (i) (vector-ref vec i)) v))))
      (vector-fill! idx '#()))))
(define (monk-sort! extract vec [timeout 1] [start 0] [end (vector-length vec)])
  (let* ([lst '()] [sema (make-semaphore 1)]
         [t (thread (λ () (let loop ([x (thread-try-receive)] [ts (current-seconds)])
                            (semaphore-wait sema)
                            (when x (set! lst (append lst (list x))) (set! ts (current-seconds)))
                            (semaphore-post sema)
                            (loop (thread-try-receive) ts))))]
         [tv (vector-map (λ (x) (thread (λ () (and (sleep (/ (extract x) 60)) (thread-send t x))))) vec)])
    (thread-wait t)
    (list->vector lst)))


(define rate (quotient (default-sample-rate) 10))
(define tone-list (build-list 100 (λ (i) (cons i (rs-mult (make-tone (- (quotient (default-sample-rate) (* 2 (- 100 i))) 100)
                                                                     0.7 rate) (hann-window rate))))))
(define-values (w h) (values 400 400))
#|
(let ([rs '()] [sr rate]
      [vec (list->vector (shuffle tone-list))] [lst '()] [ps (make-pstream)])
  (define (draw-vector a)
    (define px (/ w (vector-length vec)))
    (let* ([bmp (make-object bitmap% w h)]
           [dc (send bmp make-dc)])
      (send dc set-background "white")
      (send dc clear)
      (send dc set-pen "black" 1 'solid)
      (define (draw-bar x y)
        (if (= y a) (send dc set-brush "red" 'solid)
            (send dc set-brush "lightgray" 'solid))
        (send dc draw-rectangle (* x px) (- h (* 7/2 y)) px (* 7/2 y)))
      (for ([i (in-range (vector-length vec))])
        (draw-bar i (car (vector-ref vec i)))) bmp))
  ;(kill-thread (big-bang
  ;    (thread (λ ()
                ((hybrid-quick 3 shell-sort! #:partition hoare-partition)
                 vec (λ (x y) (set! rs (append (list (cdr x) (cdr y)) rs))
                                   (set! lst (append (list (draw-vector (car x)) (draw-vector (car y))) lst))
                                   (< (car x) (car y))))
                (set! rs (append (reverse (map cdr (vector->list vec))) rs))
                (set! lst (append (for/list ([x (in-vector vec (sub1 (vector-length vec)) -1 -1)])
                                    (draw-vector (car x))) lst)) #|
))
    [to-draw (λ (t) (let loop () (when (and (thread-running? t) (or (empty? rs) (empty? lst))) (loop)))
               (if (or (empty? rs) (empty? lst)) (draw-vector -1)
                   (begin0 (andqueue ps (last rs) (pstream-current-frame ps) (last lst))
                           (set! rs (drop-right rs 1)) (set! lst (drop-right lst 1)))))]
    [on-tick (λ (t) t) (/ rate (default-sample-rate))]
    [stop-when (λ (t) (and (not (thread-running? t)) (empty? rs) (empty? lst)))]
    [close-on-stop #t]))
;|#
  (write-animated-gif (reverse lst) (quotient (* 100 rate) (default-sample-rate)) "sorting.gif")
  (rs-write (rs-append* (reverse rs)) "sorting.wav")
  ) ;end let
;|#

(define (time-sort name proc vec srt)
  (display (format "~a: " name))
  (let ([cc 0])
    (time (and (proc vec (λ (a b) (set! cc (add1 cc)) (< a b)))
               (display (if (equal? vec srt) "passed" "failed"))
               (display (format " comparisons: ~a " cc))))))
(define-syntax-rule (bench-sort r procs ...)
  (let* ([shuf (shuffle (range r))] [vec (list->vector shuf)]
         [srt (list->vector (range r))])
    (displayln (format "Benchmarking ~a items..." r))
    (for ([name (in-list '(procs ...))]
          [proc (in-list (list procs ...))])
      (time-sort name proc vec srt)
      (set! vec (list->vector shuf)))))

(require rsound/draw)
#|
(bench-sort 10000 vector-sort! lomuto-sort! intro-sort! hoare-sort! heap-sort! shell-sort!
            (hybrid-merge 2000 heap-sort!) (hybrid-quick 3 (hybrid-length 100 shell-sort! heap-sort!) #:partition hoare-partition)
            merge-sort! insertion-sort! selection-sort! cocktail-sort! gnome-sort! comb-sort! bubble-sort!)
;|#
